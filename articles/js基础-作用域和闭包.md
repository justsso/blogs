# js基础-作用域和闭包

## 作用域

概念：查找变量的规则。

编译原理
为什么要知道编译原理呢？编译原理是从源代码到可执行代码到机器可以识别的代码的一个过程。

不同的语言的编译原理不一样，可能同样一份代码，在java中和在javascript中的执行结果不同。根本的区别就在于两者对于程序的编译的过程不同。

传统的语言是提前编译的，但js不是提前编译的。编译结果也不能在分布式系统中进行移植。

传统编译语言，程序中的源代码在执行前会经历3个步骤，统称为“编译”。

- 分词/词法分析
- 解析/语法分析
- 代码生成

**引擎查找方式有2种： LHS和RHS**

变量赋值，LHS
非变量赋值：RHS

为什么区分LHS和RHS？

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要(也就是说它们没有找到所 需的标识符)，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域(一层 楼)，最后抵达全局作用域(顶层)，无论找到或没找到都将停止。
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常(严格模式下)。

**作用域查找规则**

引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级查找。当抵达最外层的全局作用域时，无论找到还是没有找到，都会结束。

## 词法作用域
作用域有两种：词法作用域和动态作用域。js选择了词法作用域。作用域查找会在找到第一个匹配的标识符时停止。

**欺骗词法作用域**

两种机制,都不推荐使用，虽然可以欺骗词法作用域，但是会损坏性能。

- eval()
- with 关键字

严格模式下，这两种都被禁用了。

## 作用域和函数作用域

最小授权或者最小暴露原则是指应该最小限度的暴露必要内容。
有些变量或者函数应该是私有的，不应该全部暴露出去。正确的代码应该可以阻止对这些变量或者函数的访问。良好的软件都会依次实现。

用var声明的变量都会在全局作用域中。
js中有全局作用域，函数作用域，块作用域。

块作用域：
with()   try...catch...  let

let 声明的变量不会有变量提升，在块作用域之外也不会被访问到的。块作用域的好处： 闭包和垃圾回收机制
闭包的例子就是for循环了，垃圾回收机制，为变量显示声明块作用域，并对变量进行本地绑定是非常有用的工具。

变量提升，编译器会分成2部进行。第一步是变量声明，第二部是执行阶段。

我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a
和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

## 作用域闭包
jfkl 
