# js基础-作用域和闭包

## 作用域

概念：查找变量的规则。

编译原理
为什么要知道编译原理呢？编译原理是从源代码到可执行代码到机器可以识别的代码的一个过程。

不同的语言的编译原理不一样，可能同样一份代码，在java中和在javascript中的执行结果不同。根本的区别就在于两者对于程序的编译的过程不同。

传统的语言是提前编译的，但js不是提前编译的。编译结果也不能在分布式系统中进行移植。

传统编译语言，程序中的源代码在执行前会经历3个步骤，统称为“编译”。

- 分词/词法分析
- 解析/语法分析
- 代码生成

**引擎查找方式有2种： LHS和RHS**

变量赋值，LHS
非变量赋值：RHS

为什么区分LHS和RHS？

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要(也就是说它们没有找到所 需的标识符)，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域(一层 楼)，最后抵达全局作用域(顶层)，无论找到或没找到都将停止。
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常(严格模式下)。

**作用域查找规则**

引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级查找。当抵达最外层的全局作用域时，无论找到还是没有找到，都会结束。

## 词法作用域
作用域有两种：词法作用域和动态作用域。js选择了词法作用域。作用域查找会在找到第一个匹配的标识符时停止。

**欺骗词法作用域**

两种机制,都不推荐使用，虽然可以欺骗词法作用域，但是会损坏性能。

- eval()
- with 关键字

严格模式下，这两种都被禁用了。

## 作用域和函数作用域

最小授权或者最小暴露原则是指应该最小限度的暴露必要内容。
有些变量或者函数应该是私有的，不应该全部暴露出去。正确的代码应该可以阻止对这些变量或者函数的访问。良好的软件都会依次实现。

用var声明的变量都会在全局作用域中。
js中有全局作用域，函数作用域，块作用域。

块作用域：
with()   try...catch...  let

let 声明的变量不会有变量提升，在块作用域之外也不会被访问到的。块作用域的好处： 闭包和垃圾回收机制
闭包的例子就是for循环了，垃圾回收机制，为变量显示声明块作用域，并对变量进行本地绑定是非常有用的工具。

变量提升，编译器会分成2部进行。第一步是变量声明，第二部是执行阶段。

我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a
和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

## 作用域闭包

闭包的概念：
在声明时所在作用域之外调用该函数，就会产生闭包。
副作用：保留一段作用域声明周期，垃圾回收机制不能回收，作用域一直存在。

函数在它本身的词法作用域之外执行。

// function foo(){
//     var a  = 2;
//     function bar() {
//         console.log(a)
//     }
//     return bar;
// }
//
// var baz = foo();
// baz();


//闭包的例子
// function wait(message){
//     setTimeout(function timer () {
//         console.log(message)
//     }, 1000)
// }
// wait('hello world');


//for循环闭包的例子
//1s，2s,3s,4s,5s后输出的都是6
// for (var i = 1; i <= 5; i++) {
// //     setTimeout(function timer() {
// //         console.log(i)
// //     }, 100)
// // }

//这样和上面的结果一样，虽然每一个for循环都创建了一个新的词法作用域出来
// for (var i = 1; i <=5 ; i++) {
//     (function () {
//         setTimeout(function timer() {
//             console.log(i)
//         }, i*1000)
//     })()
// }


//这样可以1 2 3 4 5依次输出
//这样不仅创建了5个不同的词法作用域，还把不同循环中的i的值，传入到立即执行函数中
// for (var i = 1; i <=5 ; i++) {
//     (function (i) {
//         setTimeout(function timer() {
//             console.log(i)
//         }, i*1000)
//     })(i)
// }


//这样便不会每次手动创建一个作用域了
//因为let有拦截作用域的作用
// for (let i = 1; i <= 5; i++) {
//     setTimeout(function timer() {
//         console.log(i)
//     }, i*1000)
// }

//模块
function foo() {
    var something = 'something';
    var arr = [1,2,3];
    function a() {
        console.log(something)
    }

    function b() {
        console.log(arr.join(','))
    }
    return {
        a,
        b
    }
}

var Foo = foo();
Foo.a();
Foo.b();

### 词法作用域和动态作用域的区别：

主要区别:词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。(this 也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。