# js基础-2 异步回调

## 再说回Javascript引擎

Google V8 引擎使用 C++ 代码编写，实现了 ECMAScript 规范的第五版，可以运行在所有的主流操作系统中，甚至可以运行在移动终端 ( 基于 ARM 的处理器，如 HTC G7 等 )。V8 最早被开发用以嵌入到 Google 的开源浏览器 Chrome 中，但是 V8 是一个可以独立的模块，完全可以嵌入您自己的应用，著名的 Node.js( 一个异步的服务器框架，可以在服务端使用 JavaScript 写出高效的网络服务器 ) 就是基于 V8 引擎的。

和其他 JavaScript 引擎一样，V8 会编译 / 执行 JavaScript 代码，管理内存，负责垃圾回收，与宿主语言的交互等。V8 的垃圾回收器采用了众多技术，使得其运行效率大大提高。通过暴露宿主对象 ( 变量，函数等 ) 到 JavaScript，JavaScript 可以访问宿主环境中的对象，并在脚本中完成对宿主对象的操作。

### 克服单线程编程的缺点 —————异步回调

**JavaScript 程序的单元块**,**最常见的单元块就是函数**。

由于javascript的单线程，使得从现在到“将来”要执行的函数的这段时间时间间隙是空的，这是不能允许的。

鼠标点击、定时器、Ajax响应的函数都是异步执行的，它们关联的函数都不是立刻就执行。

其实浏览器的控制台也是异步的，其本质是I/O 的异步化。

#### 解析事件循环

**事件循环机制是由宿主环境提供的。**事件是怎么调度的，是有宿主环境控制的，可能不同的宿主环境提供的事件循环机制有所不同，javascript引擎只是去执行这些js代码。

宿主环境提供的事件循环机制并不是那么的精确。比如setTimeout()函数，能够保证在指定的时间之后把回调函数放入事件循环队列，但是此时事件循环队列已经存在未执行的函数，那么回调函数就应该等待。所以，setTimeout()可能会在指定间隔调用，也可能在指定间隔之后调用。

直到在ES6中，JavaScript才真正建立起直接的异步概念。

JavaScript 引擎本身所做的只 不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。

JavaScript 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 Web 浏览器。经过最近几年(不仅于此)的发展，JavaScript 已经超出了浏览器的范围， 进入了其他环境，比如通过像 Node.js 这样的工具进入服务器领域。实际上，JavaScript 现 如今已经嵌入到了从机器人到电灯泡等各种各样的设备中。

但是，所有这些环境都有一个共同“点”(thread，也指线程。不论真假与否，这都不算一 个很精妙的异步笑话)，即它们都提供了一种机制来处理程序中多个块的执行，且执行每 块时调用 JavaScript 引擎，这种机制被称为事件循环。

我们先从一个奇怪的说法谈起 —— 尽管 JavaScript 允许异步的代码(就像是我们刚刚说的 setTimeout) ，但直到 ES6，JavaScript 自身从未有过任何关于异步的直接概念。JavaScript 引擎只会在任意时刻执行一个程序。

### Promise

Promise的异步特性是基于任务的。

事件循环队列类似于一个游乐园游戏:玩过了一个游戏之后，你需要重新到队尾排队才能 再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。
一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环(job loop)可能无限循环(一个任务总是添加另一个任务，以此类推)，进而导致程序的 饿死，无法转移到下一个事件循环 tick。从概念上看，这和代码中的无限循环(就像 while(true)..)的体验几乎是一样的。

---
代码中语句的顺序和javascript引擎执行语句的顺序并不一定要一致。

### async await

思路： 从回调函数到promise到generator到async await 

深入底层 js的执行机制，v8引擎的执行机制，才可以了解js的异步机制。

promise 和 js异步机制是两码事吗？

js的引擎有很多中，浏览器中采用得是由谷歌发明得V8引擎。js还可以应用在物联网，硬件产品中，只是采用得引擎机制不同而已。

js执行时，v8 引擎和宿主环境结合，宿主环境就是浏览器，或者物联网硬件。

声明式编程

### 真正理解回调函数

回调函数带来两个两个缺点：
控制反转