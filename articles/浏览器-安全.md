
---
title: 浏览器中的安全
date: 2020.6.17
categories: 
- 浏览器
---

# 浏览器中的安全

浏览器中的安全分为三大块。Web网页安全，浏览器网络 安全和浏览系统安全。

安全策略：同源策略（Same-Origin policy）。如果两个url，协议相同、域名相同、端口相同，那么这两个url是同源的。浏览器认为两个相同的源之间是可以互相访问资源和操作dom的。两个不同的源之间想要访问资源或操作dom，那么会有一套安全机制制约，我们把这叫做同源策略。

同源策略会隔离不同源的DOM、，页面数据安全和网络通信，进而实现web页面的安全性。

1. 页面中可以引用第三方资源，不过这也暴露了很多诸多XSS的安全问题，比如页面加载了一个恶意脚本，该脚本会窃取用户的cookie信息。为了解决XSS攻击，浏览器中增加了CSP（内容安全策略），CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器能够执行哪些内联JavaScript代码。
2. 使用XMLHttpRequest和Fetch都是无法直接进行跨域请求的，因此浏览器在这种严格模式之上引入了CORS（跨域资源共享），让其可以安全的跨域。
3. 两个不同的源的DOM是不能互相操作的，因此浏览器中出现了跨文档消息机制，让其可以比较安全的通信。

## 跨站脚本攻击(XSS)

XSS(Cross Site Scripting)跨站脚本攻击，主要是网站加载了一些恶意脚本。恶意脚本会做以下恶事，窃取用户的cookie信息，监听用户行为，比如获取用户的输入信息；在页面生成广告。


### 恶意脚本是怎么被注入的:

- 存储型XSS

黑客将恶意脚本存储到正常服务器中，当用户请求到包含有恶意脚本的网页时，用户的浏览器就会执行恶意脚本，恶意脚本窃取用户cookie发送到黑客服务器

以喜马拉雅为例，黑客将一张专辑的名字命名为`<script src="aaa.com/b.js"></script>`，服务器将这个名字存储到数据库了，然后普通用户看这个专辑时，浏览器就会请求恶意脚本，恶意脚本会读取用户的cookie，这样用户cookie被盗用，黑客可以冒用用户登录做一些恶事了。

- 反射型XSS

恶意脚本属于用户发送给服务器端请求的一部分，然后服务器端再将恶意脚本返回给浏览器端，当恶意JavaScript脚本在用户页面中被执行时，黑客就可以利用该恶意脚本做一些事情。
比如一个不明链接，该链接的query中包含`<script>alert("你被攻击了")</script>`，那么当用户不小心点了这个链接，发送到服务器，服务器收到请求后，又将恶意代码发送给了浏览器端，这样浏览器端就读取并执行了`<script>alert("你被攻击了")</script>`


- 基于DOM的XSS

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

存储型XSS和反射性XSS是服务器的安全漏洞，基于DOM的XSS是浏览器的安全漏洞。不论哪种XSS，都是要先在浏览器中注入恶意脚本，然后通过恶意脚本再将用户信息发送到黑客服务器上。所以关键还是得浏览器端阻止恶意脚本的注入和恶意消息的发送。

基于XSS攻击，我们应该怎么防控呢？
- 服务器对于输入脚本做过滤，转码
- 前端符合CSP规范
- **cookie 中有 HttpOnly属性**，针对cookie 使用httponly，禁止JavaScript操作cookie。


说道CSP，要仔细聊聊具体要怎么做，才叫符合CSP规范呢？https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP

## CSRF攻击

CSRF(Cross Site Request Forgerys)跨站请求伪造，关键的点有，目标服务器存在漏洞、用户登录过网站并有登录态、用户被诱导进入黑客网站并用用户的登录态发送了伪造请求


CSSRF攻击，主要是利用用户登录，请求服务器的漏洞接口，所以我们的主力放在用户登录态和服务器上做以下几点来防范：

- 从用户登录态着手，用户的登录态和`cookie`有着紧密的联系，如果我们让第三方网站读取不到用户的登录态，也就构不成危害操作了。`cookie`的`Samesite`可以做到禁止某些`cookie`发送。

Samesite 选项通常有Strict Lax none 三个值

    1. Strict最严格，禁止第三方Cookie
    2. Lax 宽松，第三方站点的get方式可以携带cookie，通过 img、iframe 等标签加载的 UR禁止第三方cookie
    3. 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

- 服务器检查发起请求的网站来源，通过http头的referer和origin 检查请求来源网站是不是可靠的，进行过滤.
Origin只有域名，referer有域名和具体地址


- 服务器增加CSRF token，浏览器向服务器发起请求，服务器将csrf token注入到浏览器端，如果浏览器发送的请求不包含csrf token的话，那么服务器将验证token不合法，会拒绝请求。
